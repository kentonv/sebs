# Scalable Extendable Build System
# Copyright (c) 2009 Kenton Varda and contributors.  All rights reserved.
# Portions copyright Google, Inc.
# http://code.google.com/p/sebs
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are
# met:
#
#     * Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#     * Redistributions in binary form must reproduce the above
# copyright notice, this list of conditions and the following disclaimer
# in the documentation and/or other materials provided with the
# distribution.
#     * Neither the name of the SEBS project nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import os.path
import md5

class _EnvironmentOption(sebs.Rule):
  def __init__(self, env_name, default, description):
    super(_EnvironmentOption, self).__init__()
    self.__env_name = env_name
    self.__description = description
    self.__default = default

  def _expand(self):
    action = self.context.action(self, "configure", self.__description)
    output = self.context.memory_artifact(self.__env_name, action)

    default = self.__default
    if isinstance(default, _EnvironmentOption):
      default.expand_once()
      default = default.output

    action.set_command(sebs.EnvironmentCommand(
        self.__env_name, output, default, output_message=True))

    self.value = output.contents()
    self.output = output
    self.outputs = [output]

cc = _EnvironmentOption("CC", "cc", "C compiler")
cxx = _EnvironmentOption("CXX", "c++", "C++ compiler")
cflags = _EnvironmentOption("CFLAGS", "-O2 -g", "C compiler flags")
cxxflags = _EnvironmentOption("CXXFLAGS", cflags, "C++ compiler flags")
ldflags = _EnvironmentOption("LDFLAGS", "", "linker flags")

class SystemLibrary(sebs.Rule):
  def __init__(self, name, deps = []):
    super(SystemLibrary, self).__init__()
    self.lib = name
    self.deps = deps

  def _expand(self):
    self.outputs = []
    self.transitive_libs = set()

    for dep in self.deps:
      if not isinstance(dep, SystemLibrary):
        raise sebs.DefinitionError(
          "Dependency of system library is not a system library: %s" % dep)
      dep.expand_once()
      self.transitive_libs.add(dep.lib)
      self.transitive_libs.update(dep.transitive_libs)

  def as_cpp_library(self):
    return self

class _Base(sebs.Rule):
  def __init__(self, srcs, deps, context = None):
    super(_Base, self).__init__(context = context)
    self.srcs = srcs
    self.deps = deps

  def _expand(self):
    env_vars = [cxx, cflags, cxxflags]
    for rule in env_vars:
      rule.expand_once()
    env_artifacts = [env.output for env in env_vars]

    self.objects = []
    for src in self.srcs:
      src_artifact = self.context.source_artifact(src)
      src_filename = self.context.local_filename(src)
      if src_filename is None:
        raise sebs.DefinitionError(
          "Source file is not in this package: %s" % src)
      name, ext = os.path.splitext(src_filename)
      if ext in [".c", ".C", ".cc", ".cpp", ".cxx", ".c++"]:
        action = self.context.action(self, "compile", src_artifact.filename)
        obj = self.context.intermediate_artifact(name + ".o", action)
        self.objects.append(obj)
        action.set_command(
          sebs.SubprocessCommand(action,
                                 [cxx.value, cxxflags.value,
                                  "-Isrc", "-Itmp", "-Iinclude",
                                  "-c", src_artifact, "-o", obj]))
      elif ext not in [".h", ".H", ".hh", ".hpp", ".hxx", ".h++"]:
        raise sebs.DefinitionError(
          "File extension not recognized as a C++ source or header: %s" % src)

    self.transitive_deps = set()
    self.transitive_libs = set()
    for dep in self.deps:
      dep = dep.as_cpp_library()
      if isinstance(dep, SystemLibrary):
        dep.expand_once()
        self.transitive_libs.add(dep.lib)
        self.transitive_libs.update(dep.transitive_libs)
      elif isinstance(dep, Library):
        dep.expand_once()
        self.transitive_deps.add(dep.static_library)
        self.transitive_deps.update(dep.transitive_deps)
        self.transitive_libs.update(dep.transitive_libs)
      else:
        raise sebs.DefinitionError(
          "Dependency of C++ rule is not a C++ library: %s" % dep)

  def anonymous_name(self):
    if self.label is None:
      # Create a stable, unique temporary name for the library.
      input_digest = md5.new()
      for src in self.srcs:
        input_digest.update(self.context.local_filename(src))
      return input_digest.hexdigest()[-8:]
    else:
      return self.label

class Library(_Base):
  def __init__(self, name=None, srcs=[], deps=[], context = None):
    super(Library, self).__init__(srcs, deps, context = context)
    self.output_name = name

  def _expand(self):
    super(Library, self)._expand()

    static_link_action = self.context.action(self, "link")

    if self.output_name is None:
      # Output library to intermediate directory.
      static_lib = self.context.intermediate_artifact(
          "lib%s.a" % self.anonymous_name(), static_link_action)
    else:
      # Output library to lib directory.
      static_lib = self.context.output_artifact(
          "lib", "lib%s.a" % self.output_name, static_link_action)

    # Remove existing library, since we don't know if it was created with the
    # same set of sources.  It appears the "ar" command does not have any
    # option for "remove any files that aren't in the list".
    rm = sebs.SubprocessCommand(static_link_action, ["rm", "-f", static_lib])

    # Create the library archive, with a symbol table.
    ar = sebs.SubprocessCommand(static_link_action,
                                ["ar", "-qcs", static_lib] + self.objects)

    static_link_action.set_command(sebs.DoAllCommand([rm, ar]))

    self.static_library = static_lib
    self.outputs = [static_lib]

  def as_cpp_library(self):
    return self

class Binary(_Base):
  def __init__(self, name=None, srcs=[], deps=[]):
    super(Binary, self).__init__(srcs, deps)
    self.output_name = name

  def _expand(self):
    super(Binary, self)._expand()

    all_inputs = self.objects + list(self.transitive_deps)
    link_action = self.context.action(self, "link")

    if self.output_name is None:
      # Output binary to intermediate directory.
      output = self.context.intermediate_artifact(
          "%s_bin" % self.anonymous_name(), link_action)
    else:
      output = self.context.output_artifact(
          "bin", self.output_name, link_action)

    lib_flags = ["-l" + lib for lib in self.transitive_libs]

    link_action.set_command(
      sebs.SubprocessCommand(link_action,
        [cxx.value, "-o", output] + all_inputs + lib_flags))

    self.binary = output
    self.outputs = [output]

class Test(sebs.Test):
  def __init__(self, srcs=[], deps=[]):
    super(Test, self).__init__()
    self.__binary_rule = Binary(None, srcs, deps)

  def _expand(self):
    self.__binary_rule.label = self.label
    self.__binary_rule.expand_once()

    action = self.context.action(self, "test")
    output = self.context.intermediate_artifact(
        "%s_output.txt" % self.__binary_rule.anonymous_name(), action)
    result = self.context.memory_artifact(
        "%s_result" % self.__binary_rule.anonymous_name(), action)
    action.set_command(
        sebs.SubprocessCommand(action, [self.__binary_rule.binary],
                               capture_stdout = output,
                               capture_stderr = output,
                               capture_exit_status = result))

    self.test_result_artifact = result
    self.test_output_artifact = output

    # If built directly, build the test binary but don't run it.
    self.outputs = [self.__binary_rule.binary]
